<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="线性表的存储结构线性表有两种存储结构，分别是顺序存储结构和链式存储结构。  顺序存储结构  结点中只有自身的信息域，因此存储密度大、存储空间利用率高。 随机访问 插入和删除需要移动大量元素    链式存储结构  结点中除自身信息域外还有指针域，因此存储密度小、存储空间利用率低。 在逻辑上相邻的结点在物理上不必相邻，因此不能随机访问，只能顺序访问。 插入和删除操作方便灵活，不必移动结点，只需修改结点">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构面试题">
<meta property="og:url" content="http://blog.provence36.cn/2020/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Provence&#39; Blog">
<meta property="og:description" content="线性表的存储结构线性表有两种存储结构，分别是顺序存储结构和链式存储结构。  顺序存储结构  结点中只有自身的信息域，因此存储密度大、存储空间利用率高。 随机访问 插入和删除需要移动大量元素    链式存储结构  结点中除自身信息域外还有指针域，因此存储密度小、存储空间利用率低。 在逻辑上相邻的结点在物理上不必相邻，因此不能随机访问，只能顺序访问。 插入和删除操作方便灵活，不必移动结点，只需修改结点">
<meta property="article:published_time" content="2020-04-23T13:41:24.000Z">
<meta property="article:modified_time" content="2020-04-29T03:40:42.268Z">
<meta property="article:author" content="Provence">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.provence36.cn/2020/04/23/数据结构面试题/"/>





  <title>数据结构面试题 | Provence' Blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Provence' Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.provence36.cn/2020/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Provence">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/26401802?s=400&u=87db6b0edfa75ed2b59f1fe0f0da23215082c344&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Provence' Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构面试题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-23T21:41:24+08:00">
                2020-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%AD%E7%94%B5%E5%A4%8D%E8%AF%95%E5%87%86%E5%A4%87/" itemprop="url" rel="index">
                    <span itemprop="name">杭电复试准备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2020/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98/" class="leancloud_visitors" data-flag-title="数据结构面试题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.9k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h4><p>线性表有两种存储结构，分别是顺序存储结构和链式存储结构。</p>
<ol>
<li><p>顺序存储结构</p>
<ul>
<li>结点中只有自身的信息域，因此存储密度大、存储空间利用率高。</li>
<li>随机访问</li>
<li>插入和删除需要移动大量元素 </li>
</ul>
</li>
<li><p>链式存储结构</p>
<ul>
<li>结点中除自身信息域外还有指针域，因此存储密度小、存储空间利用率低。</li>
<li>在逻辑上相邻的结点在物理上不必相邻，因此不能随机访问，只能顺序访问。</li>
<li>插入和删除操作方便灵活，不必移动结点，只需修改结点中的指针域。</li>
</ul>
</li>
</ol>
<a id="more"></a>

<h4 id="如何实现循环队列？好处？为什么要空一个位置？"><a href="#如何实现循环队列？好处？为什么要空一个位置？" class="headerlink" title="如何实现循环队列？好处？为什么要空一个位置？"></a>如何实现循环队列？好处？为什么要空一个位置？</h4><p>如何实现：把数组弄成一个环，让rear和front指针沿着环走，这样就可以产生循环队列。</p>
<p>好处：循环队列是顺序队列的改进，在顺序队列中，在元素进队的时候，rear要向后移动，元素出队的时候，front也要向后移动，这样经过一系列的出队和入队操作之后，两个指针最后会达到数组的末端，此时虽然队中已经没有元素了，但是还是不能让元素入队，即出现了“假溢出”的现象。循环队列就能避免出现这个现象。</p>
<p>空一个位置：这是为了用来区分队空与队满的情况。如果不空一个位置，则判断队空和队满的条件是一样的。</p>
<h4 id="来讲讲二叉树吧"><a href="#来讲讲二叉树吧" class="headerlink" title="来讲讲二叉树吧"></a>来讲讲二叉树吧</h4><p>定义：</p>
<p>二叉树是一种树形结构，它的特点是每个结点至多有两棵子树，并且二叉树的子树有左右之分。</p>
<p>（递归定义）二叉树是n（n≥0）个结点的有限集合：</p>
<ol>
<li>或者为空二叉树</li>
<li>或者由一个根结点和根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</li>
</ol>
<p>特殊的二叉树：</p>
<ol>
<li><p>满二叉树</p>
<p>一棵高度为h，且含有$2^h-1$个结点的二叉树称为满二叉树，即树的每层都含有最多的结点。</p>
</li>
<li><p>完全二叉树</p>
<p>设一个高度为h、有n个结点的二叉树，当且仅当每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树。</p>
</li>
<li><p>二叉排序树</p>
<p>左子树上的所有结点的关键字都小于根结点的关键字，右子树上的所有结点的关键字都大于根结点的关键字。左右子树又各是一棵二叉排序树。</p>
</li>
<li><p>平衡二叉树</p>
<p>二叉排序树上任意结点的左子树和右子树的高度差不超过1</p>
</li>
</ol>
<h4 id="度为二的树和二叉树的区别"><a href="#度为二的树和二叉树的区别" class="headerlink" title="度为二的树和二叉树的区别"></a>度为二的树和二叉树的区别</h4><ol>
<li>度为2的树至少有3个结点，而二叉树可以为空。</li>
<li>度为2的有序树的孩子结点的左右次序是相对于另一个孩子结点而言的。若某个结点只有一个孩子结点，则这个孩子结点就无须区分其左右次序。而二叉树无论孩子结点数是否为2，均需确定其左右次序。</li>
</ol>
<h4 id="二叉树的存储方式和遍历方式"><a href="#二叉树的存储方式和遍历方式" class="headerlink" title="二叉树的存储方式和遍历方式"></a>二叉树的存储方式和遍历方式</h4><p>存储方式：</p>
<ol>
<li><p>顺序存储</p>
<p>用一维数组存放二叉树中的结点，从树根开始，从上到下，每层从左到右地给所有结点按完全二叉树的树形编号，若某位置没有结点，则数组对应的位置为0。</p>
<p>完全二叉树和满二叉树采用顺序存储比较合适，既能够节省存储空间，又可以利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。</p>
</li>
<li><p>链式存储</p>
<p>链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别指向该结点的左子树和右子树。</p>
</li>
</ol>
<p>遍历方式：</p>
<ol>
<li><p>先序遍历</p>
<p>先访问根结点，先序遍历左子树，先序遍历右子树</p>
</li>
<li><p>中序遍历</p>
<p>中序遍历左子树，访问根结点，中序遍历右子树</p>
</li>
<li><p>后序遍历</p>
<p>后序遍历左子树，后序遍历右子树，访问根结点</p>
</li>
<li><p>层序遍历</p>
<p>借助队列实现。先将根结点入队，然后出队，访问该结点，若它有左子树，则将该左子树根结点入队；若它有右子树，则将该右子树根结点入队。然后出队，对出队结点访问，重复以上操作，直到队列为空。</p>
</li>
</ol>
<h4 id="树的存储结构和遍历方式"><a href="#树的存储结构和遍历方式" class="headerlink" title="树的存储结构和遍历方式"></a>树的存储结构和遍历方式</h4><p>存储结构：</p>
<ol>
<li><p>双亲表示法</p>
<p>采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。根结点下标为0，伪指针域为-1。</p>
<p>可以很快找到双亲，但求结点的孩子需要遍历整个结构。</p>
</li>
<li><p>孩子表示法</p>
<p>把每个结点的孩子结点都用单链表链接起来形成一个线性结构，n个结点就有n个孩子链表，叶子结点的孩子链表为空表。</p>
<p>求结点的孩子简单，寻找双亲需要遍历n-1个孩子链表。</p>
</li>
<li><p>孩子兄弟表示法</p>
<p>每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）。</p>
<p>可以方便地实现数转换成二叉树的操作，易于查找结点的孩子，但查找孩子的双亲结点比较麻烦。</p>
</li>
</ol>
<p>遍历方式：</p>
<ol>
<li><p>先根遍历</p>
<p>若树非空，则先访问根结点，再按从左到右的顺序遍历根结点的每棵子树。</p>
</li>
<li><p>后根遍历</p>
<p>若树非空，则先按从左到右的顺序遍历根结点的每棵子树，再访问根结点。</p>
</li>
</ol>
<h4 id="什么是二叉排序树？二叉排序树的查找过程？"><a href="#什么是二叉排序树？二叉排序树的查找过程？" class="headerlink" title="什么是二叉排序树？二叉排序树的查找过程？"></a>什么是二叉排序树？二叉排序树的查找过程？</h4><p>定义：</p>
<ol>
<li>要么二叉排序树是一棵空树。</li>
<li>要么二叉排序树由根结点、左子树、右子树组成，其中左子树和右子树都是二叉排序树，且左子树上所有结点的数据域均<strong>小于</strong>根结点的数据域，右子树上所有结点的数据域均<strong>大于</strong>根结点的数据域。</li>
</ol>
<p>查找过程：</p>
<p>若查找的关键字等于根结点的关键字，则查找成功。</p>
<p>若查找的关键字小于根结点的关键字，递归查找左子树。</p>
<p>若查找的关键字大于根结点的关键字，递归查找右子树。</p>
<p>若子树为空，则查找失败。</p>
<p>二叉排序树的中序遍历是一个递增序列。</p>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>定义：</p>
<p>在含有n个带权叶子结点的二叉树中，其中带权路径长度最小的树为哈弗曼树。</p>
<p>构造方法：</p>
<ol>
<li>初试状态下共有n个结点，将他们视作n棵只有根结点的树。</li>
<li>合并其中根结点权值最小的两棵树，生成两棵树根结点的父结点，权值为这两个根结点的权值之和，这样树的数量就减少了一个。</li>
<li>重复上一步，直到只剩一棵树。</li>
</ol>
<p>特点：</p>
<ol>
<li>权值越小，离根结点越远。</li>
<li>树中所有结点度都为2。</li>
</ol>
<p>应用：</p>
<p>哈夫曼编码：是总长度最短的前缀编码。</p>
<h4 id="图的相关概念"><a href="#图的相关概念" class="headerlink" title="图的相关概念"></a>图的相关概念</h4><p>图：由结点的有穷集合V和边的集合E组成。</p>
<p>类别：有向图和无向图。</p>
<p>顶点的度：出度和入度。</p>
<p>有向完全图和无向完全图：  </p>
<ul>
<li><p>若有向图有n个顶点，则最多有n(n-1)条边，则称为有向完全图；</p>
</li>
<li><p>若无向图有n个顶点，则最多有n(n-1)/2条边，则称为无向完全图。</p>
</li>
</ul>
<p>路径：由顶点和相邻顶点序偶构成的边所形成的序列。</p>
<p>简单路径：序列中的顶点和路径不重复出现的路径。</p>
<p>回路：路径中第一个顶点和最后一个顶点相同的路径。</p>
<p>连通：   </p>
<ul>
<li><p>无向图中，如果Vi到Vj有路径，则称这两个顶点连通。如果图中任意两个顶点之间都连通，则称改图为连通图。</p>
</li>
<li><p>有向图中，如果Vi到Vj有路径，则称这两个顶点连通。如果图中每一对顶点Vi和Vj，从Vi到Vj和Vj到Vi都有路径，则称改图为强连通图。</p>
</li>
</ul>
<h4 id="图的存储方式和遍历方式"><a href="#图的存储方式和遍历方式" class="headerlink" title="图的存储方式和遍历方式"></a>图的存储方式和遍历方式</h4><p>存储方式：</p>
<ol>
<li><p>邻接矩阵法</p>
<p>用两个数组来表示图，一个一维数组存储顶点信息，一个二维数组（成为邻接矩阵）存储边的信息。</p>
</li>
<li><p>邻接表法</p>
<p>图中的顶点用一个一维数组存储，在顶点数组中，每个数据元素需要存储一个指向第一个邻接点的指针。该顶点的邻接点组成一个线性表，用单链表存储。</p>
</li>
<li><p>十字链表</p>
<p>有向图的一种链式存储结构</p>
</li>
<li><p>邻接多重表</p>
<p>无向图的一种链式存储结构</p>
</li>
</ol>
<p>遍历方式：</p>
<ol>
<li><p>深度优先搜索</p>
<p>深度优先搜索是一个递归的过程。首先，选定一个出发点后进行遍历，如果有邻接的未被访问过的结点则访问这个结点。如果没有邻接且未被访问过的结点，则回退一步，看该结点有没有邻接且未被访问过的结点。有则访问，无则再次回退，重复此过程，直到该连通块中所有顶点都被访问过。</p>
</li>
<li><p>广度优先搜索</p>
<p>从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的各个未曾访问过的邻接点，直至图中所有的顶点都被访问到。</p>
</li>
</ol>
<p>图的深度优先搜索是否唯一：</p>
<p>如果每个结点都只有一个孩子结点，那就是唯一的。否则，不唯一。</p>
<p>深度优先搜索形成的是森林。</p>
<h4 id="图和树的区别"><a href="#图和树的区别" class="headerlink" title="图和树的区别"></a>图和树的区别</h4><p>树是一种“层次”关系，图是“网络”关系。</p>
<p>树是一对多的关系，图是多对多的关系。</p>
<h4 id="什么是最小生成树？求最小生成树的方法"><a href="#什么是最小生成树？求最小生成树的方法" class="headerlink" title="什么是最小生成树？求最小生成树的方法"></a>什么是最小生成树？求最小生成树的方法</h4><p>最小生成树是在一个给定的无向图中求一棵树，使得这棵树拥有图中的所有顶点，且所有边都是来自图中的边，并且满足整棵树的边权之和最小。</p>
<ol>
<li><p>Prim算法</p>
<p>基本思想：设置集合S来存放已访问过的点，每次从未访问的点中找到离集合S最近的点，访问它并加入集合S，并遍历与该点相邻的点，如果能使之离集合S更近，则更新。</p>
</li>
<li><p>Kruskal算法</p>
<p>基本思想：首先将每条边按边权从小到大的顺序排列，然后取出边权最小的边，如果没有构成回路，则把这条边加入最小生成树中，一直重复该操作直到加入了n-1条边为止。</p>
</li>
</ol>
<h4 id="求最短路径的方法"><a href="#求最短路径的方法" class="headerlink" title="求最短路径的方法"></a>求最短路径的方法</h4><ol>
<li><p>Dijkstra算法</p>
<p>设有两个顶点集合S和T，其中集合S中存放的是已被访问的顶点，集合T中存放的是未被访问的顶点。每次从集合T中选择与起点s的最短距离最小的一个顶点u，访问u并加入集合S。之后，令顶点u为中介点，优化起点s与所有u能到达的顶点v之间的最短距离。重复以上操作，直到集合S已经包含所有顶点。</p>
<p>不能解决有负边权的图的最短路径</p>
</li>
<li><p>Floyd算法</p>
<p>如果存在一个顶点k，使得以k作为中介点时，顶点i到顶点j的最短距离缩短，则更新dis[i][j] = dis[i][k] + dis[k][j]  </p>
</li>
<li><p>Bellman-Ford算法</p>
</li>
<li><p>SPFA算法</p>
</li>
</ol>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面。每个有向无环图都有一个或多个拓扑排序序列。</p>
<p>求解拓扑排序的方法：</p>
<ol>
<li>定义一个队列Q，并把所有入度为0的结点加入队列。</li>
<li>取队首结点，输出。然后删去所有从它出发的边，并令这些边到达的顶点的入度减1，如果某个顶点的入度减为0，则将其加入队列。</li>
<li>反复进行2操作，直到队列为空。如果队列为空时入过队的结点数目恰好为N，说明拓扑排序成功，图G为有向无环图；否则，拓扑排序失败，图G中有环。</li>
</ol>
<p>拓扑排序的很重要的应用就是判断一个给定的图是否是有向无环图。</p>
<h4 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h4><p>AOE网中的最长路径是关键路径，关键路径上的活动为关键活动。</p>
<p>求解关键活动的方法：</p>
<ol>
<li>按拓扑序和逆拓扑序分别计算各顶点的最早发生时间和最迟发生时间。<br>最早（拓扑序）：ve[j] = max{ve[i] + length[i-&gt;j]}<br>最迟（逆拓扑序）：vl[i] = min{vl[j] - length[i-&gt;j]}</li>
<li>用上面的结果计算各边的最早开始时间和最迟开始时间。<br>最早：e[i-&gt;j] = ve[i]<br>最迟：l[i-&gt;j] = vl[j] - length[i-&gt;j]</li>
<li>e[i-&gt;j] == l[i-&gt;j]的活动就是关键活动</li>
</ol>
<h4 id="折半查找，以及其适用范围和时间复杂度"><a href="#折半查找，以及其适用范围和时间复杂度" class="headerlink" title="折半查找，以及其适用范围和时间复杂度"></a>折半查找，以及其适用范围和时间复杂度</h4><p>基本思路：首先，假设表中元素是升序排列，将给定值key与表中中间位置的关键字比较，若相等，则查找成功；若不等，则利用中间位置将表分为前半部分和后半部分，如果中间位置的关键字大于给定的key，则进一步查找表的前半部分，否则查找表的后半部分。重复以上操作，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p>
<p>适用范围：有序的顺序表</p>
<p>时间复杂度：O(log2n)</p>
<h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>综合了顺序查找和折半查找。</p>
<p>基本思想：</p>
<p>将查找表分为若干子块。块内的元素可以无序，但块之间是有序的，即第一个块中的关键字均小于第二个块中的关键字，第二个块中的关键字均小于第三个块中的关键字，以此类推。再建一个索引表，索引表中的每个元素含有各块的最大关键字和各块中第一个元素的地址，索引表按关键字有序排列。</p>
<p>分块查找的步骤：</p>
<ol>
<li>在索引表中确定待查记录所在的块，可以顺序查找或折半查找</li>
<li>在块内顺序查找</li>
</ol>
<h4 id="介绍一下B树和B-树"><a href="#介绍一下B树和B-树" class="headerlink" title="介绍一下B树和B+树"></a>介绍一下B树和B+树</h4><h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><p>B树是一棵多路平衡查找树。</p>
<p>M阶B树：</p>
<ol>
<li>排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则</li>
<li>子树个数：根结点的子树（2 ≤ n ≤ M），其他非叶结点的子树（ceil(M/2) ≤ n ≤ M）</li>
<li>关键字个数：子树个数-1</li>
<li>所有的叶结点都出现在同一层次上，并且不带信息</li>
</ol>
<p>B树的查找：</p>
<p>包含两个基本操作：<strong>在B树中找结点</strong>和<strong>在结点中找关键字</strong>。由于B树尝存储在磁盘上，因此前一个查找操作时在磁盘上进行的，而后一个查找操作是在内存中进行的，即在找到目标结点后，先将结点中的信息读入内存，然后采用顺序查找法或折半查找法查找。</p>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>M阶B+树：</p>
<ol>
<li>子树个数：根结点的子树（2 ≤ n ≤ M），其他非叶结点的子树（ceil(M/2) ≤ n ≤ M）</li>
<li>关键字个数：等于子树个数</li>
<li>所有的叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排序，并且相邻叶结点按大小顺序相互链接起来。</li>
</ol>
<h5 id="M阶B树和M阶B-树的主要区别"><a href="#M阶B树和M阶B-树的主要区别" class="headerlink" title="M阶B树和M阶B+树的主要区别"></a>M阶B树和M阶B+树的主要区别</h5><ol>
<li>在B+树中，具有n个关键字的结点只含有n棵子树，而在B树中，具有n个关键字的结点含有n+1棵子树。</li>
<li>在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针。而在B树中，每个关键字对应记录的存储地址。</li>
<li>在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。</li>
</ol>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>B+<strong>树的层级更少</strong>：相较于B树，B+树每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快。</li>
<li>B+<strong>树查询速度更稳定</strong>：B+树所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定。</li>
<li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li>
</ol>
<p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p>
<h4 id="什么哈希表？如何构造哈希函数？什么是哈希冲突？如何解决？"><a href="#什么哈希表？如何构造哈希函数？什么是哈希冲突？如何解决？" class="headerlink" title="什么哈希表？如何构造哈希函数？什么是哈希冲突？如何解决？"></a>什么哈希表？如何构造哈希函数？什么是哈希冲突？如何解决？</h4><p>哈希表是根据关键字而直接访问的数据结构。哈希表建立了关键字和存储地址之间的一种映射关系。</p>
<p>哈希函数的构造方法：</p>
<ol>
<li>直接定址法：直接取关键字的某个线性函数值为哈希地址</li>
<li>除留余数法：关键是要选好除数p，等概率，减少冲突</li>
<li>数字分析法：取关键字的若干不易冲突的数位组成哈希地址</li>
<li>平方取中法：取关键字平方后的中间几位为哈希地址</li>
</ol>
<p>哈希冲突：多个关键字映射到同一个存储地址。</p>
<p>解决办法：</p>
<ol>
<li><p>开放定址法</p>
<ol>
<li><p>线性探测法</p>
<p>冲突发生时，顺序查看表中下一个单元直到找到空闲单元</p>
<p>产生堆积问题，降低查找效率</p>
</li>
<li><p>平方探测法</p>
<p>可以避免堆积问题，但不能探测到哈希表上所有的地址</p>
</li>
<li><p>再散列法</p>
<p>当通过第一个哈希函数得到的地址发生冲突时，则利用第二个哈希函数计算该关键字的地址增量</p>
</li>
</ol>
</li>
<li><p>链地址法</p>
<p>将所有关键字为同义词的结点链接在同一个链表中</p>
<p>适用于经常插入和删除的情况</p>
</li>
</ol>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><h4 id="各种排序算法的复杂度、稳定性"><a href="#各种排序算法的复杂度、稳定性" class="headerlink" title="各种排序算法的复杂度、稳定性"></a>各种排序算法的复杂度、稳定性</h4><table>
  <tr>
      <td rowspan="2"></td>
    <td rowspan="2">排序方法</td>
    <td colspan="3">时间复杂度</td>
    <td rowspan="2">空间复杂度</td>
    <td rowspan="2">稳定性</td>
  </tr>
  <tr>
      <td>最好情况</td>
    <td>平均情况</td>
    <td>最坏情况</td>
  </tr>
  <tr>
      <td rowspan="3">插入排序</td>
    <td>直接插入</td>
    <td>O(n)</td>
    <td>O(n^2)</td>
    <td>O(n^2)</td>
    <td>O(1)</td>
    <td>稳定</td>
  </tr>
  <tr>
    <td>折半插入</td>
    <td></td>
    <td>O(n^2)</td>
    <td>O(n^2)</td>
    <td>O(1)</td>
    <td>稳定</td>
  </tr>
  <tr>
    <td>希尔排序</td>
    <td></td>
    <td></td>
    <td></td>
    <td>O(1)</td>
    <td>不稳定</td>
  </tr>
  <tr>
      <td rowspan="2">交换排序</td>
    <td>冒泡排序</td>
    <td>O(n)</td>
    <td>O(n^2)</td>
    <td>O(n^2)</td>
    <td>O(1)</td>
    <td>稳定</td>
  </tr>
  <tr>
    <td>快速排序</td>
    <td>O(nlog2n)</td>
    <td>O(nlog2n)</td>
    <td>O(n^2)</td>
    <td>O(log2n)</td>
    <td>不稳定</td>
  </tr>
  <tr>
      <td rowspan="2">选择排序</td>
    <td>简单选择</td>
    <td>O(n^2)</td>
    <td>O(n^2)</td>
    <td>O(n^2)</td>
    <td>O(1)</td>
    <td>不稳定</td>
  </tr>
  <tr>
    <td>堆排序</td>
    <td>O(nlog2n)</td>
    <td>O(nlog2n)</td>
    <td>O(nlog2n)</td>
    <td>O(1)</td>
    <td>不稳定</td>
  </tr>
  <tr>
      <td rowspan="2">其他排序</td>
    <td>二路归并</td>
   <td>O(nlog2n)</td>
    <td>O(nlog2n)</td>
    <td>O(nlog2n)</td>
    <td>O(n)</td>
    <td>稳定</td>
  </tr>
  <tr>
    <td>基数排序</td>
    <td>O(d(n+r))</td>
    <td>O(d(n+r))</td>
    <td>O(d(n+r))</td>
    <td>O(r)</td>
    <td>稳定</td>
  </tr>
</table>

<p>折半插入排序仅减少了比较元素的次数，而元素的移动次数并没有改变，所以时间复杂度为O(n^2)。</p>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>从前往后依次两两比较相邻元素的值，若为逆序，则交换它们，直到序列比较完。这为一趟冒泡，结果是将最大的元素交换到待排序列的最后一个位置。下一趟冒泡时，前一趟确定的最大元素将不再参与比较，待排序列减少了一个元素，每趟冒泡的结果时把序列中的最大元素放到了序列的最终位置，最多经过n-1趟冒泡就能把所有元素排好序。</p>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><ol>
<li>先从数列中取出一个数作为基准数</li>
<li>将比这个数大的数都放到右边，比这个数小的数都放到左边</li>
<li>再对其左右分区重复以上过程，直到各区间只有一个数</li>
</ol>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>假设待排序表含有n个记录，则可将其视为n个有序的字表，每个子表的长度为1，然后两两归并，得到ceil(n/2)个长度为2或1的有序表，然后又两两归并……如此重复，直到合并成一个长度为n的有序表为止。</p>
<h5 id="什么是堆？有什么作用？"><a href="#什么是堆？有什么作用？" class="headerlink" title="什么是堆？有什么作用？"></a>什么是堆？有什么作用？</h5><p>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子结点的值。如果父亲结点的值大于等于孩子结点的值，那么称这样的堆为大根堆；如果父亲结点的值小于等于孩子结点的值，那么称这样的堆为小根堆；</p>
<p>基本操作：</p>
<ol>
<li><p>向下调整</p>
<p>把当前结点V和它的孩子结点比较，假如孩子结点中存在比当前结点V大的，就把权值大的孩子结点和当前结点V交换；交换完毕后，继续让结点V和孩子比较，直到结点V的孩子的权值都比结点V的值小或者是结点V无孩子结点。</p>
</li>
<li><p>建堆</p>
<p>从最后一个有孩子结点的地方开始，进行向下调整，一直到根结点</p>
</li>
<li><p>向上调整</p>
<p>在添加元素时，需要向上调整。向上调整就是把结点和父结点比较，如果大于父结点，就和父结点交换，这样反复比较直到到达堆顶或者小于父结点为止。</p>
</li>
</ol>
<p>作用：应用于堆排序。</p>
<p>假设是最大堆，堆排序就是把堆顶元素和当前堆的最后一个元素交换位置，再进行一次对堆顶元素的向下调整，再次成为最大堆，然后再把堆顶元素和当前堆的最后一个元素交换位置…一直反复，直到堆中只有一个元素。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/15/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/" rel="next" title="关键路径">
                <i class="fa fa-chevron-left"></i> 关键路径
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="计算机组成面试题">
                计算机组成面试题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars3.githubusercontent.com/u/26401802?s=400&u=87db6b0edfa75ed2b59f1fe0f0da23215082c344&v=4"
                alt="Provence" />
            
              <p class="site-author-name" itemprop="name">Provence</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/provence3658" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:13386528836@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#线性表的存储结构"><span class="nav-number">1.</span> <span class="nav-text">线性表的存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何实现循环队列？好处？为什么要空一个位置？"><span class="nav-number">2.</span> <span class="nav-text">如何实现循环队列？好处？为什么要空一个位置？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#来讲讲二叉树吧"><span class="nav-number">3.</span> <span class="nav-text">来讲讲二叉树吧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#度为二的树和二叉树的区别"><span class="nav-number">4.</span> <span class="nav-text">度为二的树和二叉树的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的存储方式和遍历方式"><span class="nav-number">5.</span> <span class="nav-text">二叉树的存储方式和遍历方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树的存储结构和遍历方式"><span class="nav-number">6.</span> <span class="nav-text">树的存储结构和遍历方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是二叉排序树？二叉排序树的查找过程？"><span class="nav-number">7.</span> <span class="nav-text">什么是二叉排序树？二叉排序树的查找过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈夫曼树"><span class="nav-number">8.</span> <span class="nav-text">哈夫曼树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图的相关概念"><span class="nav-number">9.</span> <span class="nav-text">图的相关概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图的存储方式和遍历方式"><span class="nav-number">10.</span> <span class="nav-text">图的存储方式和遍历方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图和树的区别"><span class="nav-number">11.</span> <span class="nav-text">图和树的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是最小生成树？求最小生成树的方法"><span class="nav-number">12.</span> <span class="nav-text">什么是最小生成树？求最小生成树的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#求最短路径的方法"><span class="nav-number">13.</span> <span class="nav-text">求最短路径的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拓扑排序"><span class="nav-number">14.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键路径"><span class="nav-number">15.</span> <span class="nav-text">关键路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#折半查找，以及其适用范围和时间复杂度"><span class="nav-number">16.</span> <span class="nav-text">折半查找，以及其适用范围和时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分块查找"><span class="nav-number">17.</span> <span class="nav-text">分块查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#介绍一下B树和B-树"><span class="nav-number">18.</span> <span class="nav-text">介绍一下B树和B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B树"><span class="nav-number">18.1.</span> <span class="nav-text">B树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-树"><span class="nav-number">18.2.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#M阶B树和M阶B-树的主要区别"><span class="nav-number">18.3.</span> <span class="nav-text">M阶B树和M阶B+树的主要区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#特点"><span class="nav-number">18.4.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么哈希表？如何构造哈希函数？什么是哈希冲突？如何解决？"><span class="nav-number">19.</span> <span class="nav-text">什么哈希表？如何构造哈希函数？什么是哈希冲突？如何解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KMP算法"><span class="nav-number">20.</span> <span class="nav-text">KMP算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#各种排序算法的复杂度、稳定性"><span class="nav-number">21.</span> <span class="nav-text">各种排序算法的复杂度、稳定性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#冒泡排序"><span class="nav-number">21.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#快速排序"><span class="nav-number">21.2.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#归并排序"><span class="nav-number">21.3.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是堆？有什么作用？"><span class="nav-number">21.4.</span> <span class="nav-text">什么是堆？有什么作用？</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Provence</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '60zWr4rbDnDlADQqNvvFcdyR-gzGzoHsz',
        appKey: 'O5FKNYCgpStp3991PuerMonY',
        placeholder: '欢迎畅所欲言~',
        avatar:'monsterid',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("60zWr4rbDnDlADQqNvvFcdyR-gzGzoHsz", "O5FKNYCgpStp3991PuerMonY");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618},"display":{"superSample":2,"width":200,"height":400,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":false},"react":{"opacity":0.7},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
